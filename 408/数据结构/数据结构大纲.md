[TOC]

【考查目标】

1.掌握数据结构的基本概念、基本原理和基本方法。

2.掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度

与空间复杂度的分析。

3.能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用 C 或 C++语言设计

与实现算法的能力。

# 零 语言基础 / 时间空间复杂度 / 数据结构和算法的基本概念

## 0.1 节点的构造

**链表的节点：**

```
typedef struct Node
{
	int data;
	struct Node *next;
}Node;
```

**二叉树节点：**

```
typedef struct BTNode
{
	int data;
	struct BTNode *lchild;
	struct BTNode *rchild;
}BTNode;
```

**制造二叉树节点的两种方法：**

```
BTNode BT;
//制作一个结点
```

```
BTNode *BT;
BT = (BTNode*)malloc(sizeof(BTNOde));
//先定义一个结点的指针BT，然后用malloc()来申请一个结点的内存空间，最后让指针BT指向这片内存空间
```

|            | 方法1          | 方法2                      |
| ---------- | -------------- | -------------------------- |
| BT的含义   | 某个节点的名字 | 指针型变量                 |
| 取分量操作 | x=BT.data      | x=BT->data  / x=(*BT).data |

**"模版：利用空间申请函数（malloc()）申请一个结点空间，并用一个指针指向这个空间“：**

```
p=(   *)malloc(sizeof(   ))
```

## 0.2 函数的注意事项

1. 传入的参数是否会被改变：

   ```
   int a;
   void f(int x)
   {
   	++x;
   }
   
   a=0;
   f(a);
   ```

   最后a=0;（）

   应该使用**函数参数的引用定义**

   ```
   void f(int &x)
   {
   	++x;
   }
   ```

   传入的若是：**指针型变量**，需要：

   ```
   void f(int *&x)
   {
   	++x;
   }
   ```

   当参数是一个**一维数组**：

   ```
   void f(int x[])
   {
   	...;
   }
   ```

   当参数是一个**二维数组**:

   ```
   void f(int x[][maxSize])
   {
   	...;
   }
   ```
   

2. 其他：

   ```
   void insert(Sqlist &L,int x)
   {
       int p,i;
       p=LocateElem(L,x);
       for (i=L.length-1;i>=p;--i)
           L.data[i+1]=L.[i];
       L.data[p]=x;
       ++(L.length);
   }
   //改变L.data => L改变 => 使用引用型
   ```

   ```
   int SearchAndDelete(LNode *C,int x)
   {
       LNode *p.*q;
       p=c;
       while(p->next!=NULL)
       {
           if(p->Next->data!=x)
               break;
           p=p->Next;
       }
       if(p->next==NULL) return 0;
       else
       {
           q=p->next;
           p->next=p->next->next;
           free(q);
           return 1;
       }
   }
   //C不过是个指向链表表头的指针
   ```

   ```
   void merge(LNode *A,LNode *B,LNode *&C)
   {
       LNode *p = A->next;
       LNode *q = B->next;
       LNode *r;
       C=A;
       C->next = NULL;
       free(B);
       r=C;
       ...
   }
   //合并两个链表（A，B）为一个（C）
   ```

   PS：改变的就变引用的

## 0.3 时间复杂度分析



## 0.4 空间复杂度分析



## 0.5 数据的物理（存储）结构

- 顺序存储方法
- 链式存储方法
- 索引存储方法
- 散列存储方法

## 0.6 算法的基本概念

算法的特性：

1. 有穷性
2. 确定性
3. 输入
4. 输出
5. 可行性

算法的设计目标：

1. 正确性
2. 可读性
3. 健壮性
4. 高效率和低存储量需求

# 一、线性表

## 1.1 线性表的基本概念

### 1.1.1 线性表的定义

定义：

**线性表**是 具有相同数据类型的n个数据元素的有限序列

特点：

1. 个数有限
2. 有逻辑上的顺序性
3. 每个元素都是数据元素，每个元素都是单个元素（注意与List<T>的区分
4. 元素的数据类型都相同，占有相同大小的存储空间
5. 除了表头元素外，每个元素有且仅有一个 直接前驱（废话，不然为啥要叫线性表
6. 除了表尾元素外，每个元素有且仅有一个 直接后继（废话
7. 线性表是抽象逻辑

>线性表：逻辑结构，表示的是关系
>
>顺序表，链表：存储结构

### 1.1.2 线性表的基本操作

| 函数            | 功能     | 说明               |
| --------------- | -------- | ------------------ |
| InitList(&L)    | 初始化表 | 构造一个空的线性表 |
| Length(L)       | 求表长   | 返回线性表L的长度  |
| LocateElem(L,e) |          |                    |
|                 |          |                    |
|                 |          |                    |
|                 |          |                    |
|                 |          |                    |
|                 |          |                    |
|                 |          |                    |



## 1.2线性表的实现

### 1.2.1 顺序存储:顺序表

顺序表定义：





### 2.链式存储

## (三)线性表的应用

# **二、栈、队列和数组**

## (一)栈和队列的基本概念

## (二)栈和队列的顺序存储结构

## (三)栈和队列的链式存储结构

## (四)多维数组的存储

## (五)特殊矩阵的压缩存储

## (六)栈、队列和数组的应用

# **三、树与二叉树**

## (一)树的基本概念

## (二)二叉树

### 1.二叉树的定义及其主要特征

### 2.二叉树的顺序存储结构和链式存储结构

### 3.二叉树的遍历

### 4.线索二叉树的基本概念和构造

## (三)树、森林

### 1.树的存储结构

### 2.森林与二叉树的转换

### 3.树和森林的遍历

## (四)树与二叉树的应用

### 1.二叉搜索树

### 2.平衡二叉树

### 3.哈夫曼(Huffman)树和哈夫曼编码

# **四、图**

## (一)图的基本概念

## (二)图的存储及基本操作

### 1.邻接矩阵法

### 2.邻接表法

### 3.邻接多重表、十字链表

## (三)图的遍历

### 1.深度优先搜索

### 2.广度优先搜索

## (四)图的基本应用

### 1.最小(代价)生成树

### 2.最短路径

### 3.拓扑排序

### 4.关键路径

# **五、查找**

## (一)查找的基本概念

## (二)顺序查找法

## (三)分块查找法

## (四)折半查找法

## (五)B 树及其基本操作、B+树的基本概念

## (六)散列(Hash)表 

## (七)字符串模式匹配

## (八)查找算法的分析及应用

# **六、排序**

## (一)排序的基本概念

## (二)插入排序

### 1.直接插入排序

### 2.折半插入排序

## (三)起泡排序(bubble sort)

## (四)简单选择排序

## (五)希尔排序(shell sort)

## (六)快速排序

## (七)堆排序

## (八)二路归并排序(mergesort)

## (九)基数排序

## (十)外部排序

## (十一)各种排序算法的比较

## (十二)排序算法的应用

